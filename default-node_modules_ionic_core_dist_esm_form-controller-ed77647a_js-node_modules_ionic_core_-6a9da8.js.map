{"version":3,"file":"default-node_modules_ionic_core_dist_esm_form-controller-ed77647a_js-node_modules_ionic_core_-6a9da8.js","mappings":"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","sources":["./node_modules/@ionic/core/dist/esm/form-controller-ed77647a.js","./node_modules/@ionic/core/dist/esm/input.utils-ec063df4.js","./node_modules/@ionic/core/dist/esm/notch-controller-8c9c0e54.js","./node_modules/@ionic/core/dist/esm/theme-17531cdf.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { h as findItemLabel } from './helpers-3379ba19.js';\n\n/**\n * Creates a controller that tracks whether a form control is using the legacy or modern syntax. This should be removed when the legacy form control syntax is removed.\n *\n * @internal\n * @prop el: The Ionic form component to reference\n */\nconst createLegacyFormController = (el) => {\n  const controlEl = el;\n  let legacyControl;\n  const hasLegacyControl = () => {\n    if (legacyControl === undefined) {\n      /**\n       * Detect if developers are using the legacy form control syntax\n       * so a deprecation warning is logged. This warning can be disabled\n       * by either using the new `label` property or setting `aria-label`\n       * on the control.\n       * Alternatively, components that use a slot for the label\n       * can check to see if the component has slotted text\n       * in the light DOM.\n       */\n      const hasLabelProp = controlEl.label !== undefined || hasLabelSlot(controlEl);\n      const hasAriaLabelAttribute = controlEl.hasAttribute('aria-label') ||\n        // Shadow DOM form controls cannot use aria-labelledby\n        (controlEl.hasAttribute('aria-labelledby') && controlEl.shadowRoot === null);\n      const legacyItemLabel = findItemLabel(controlEl);\n      /**\n       * Developers can manually opt-out of the modern form markup\n       * by setting `legacy=\"true\"` on components.\n       */\n      legacyControl =\n        controlEl.legacy === true || (!hasLabelProp && !hasAriaLabelAttribute && legacyItemLabel !== null);\n    }\n    return legacyControl;\n  };\n  return { hasLegacyControl };\n};\nconst hasLabelSlot = (controlEl) => {\n  const root = controlEl.shadowRoot;\n  if (root === null) {\n    return false;\n  }\n  /**\n   * Components that have a named label slot\n   * also have other slots, so we need to query for\n   * anything that is explicitly passed to slot=\"label\"\n   */\n  if (NAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.querySelector('[slot=\"label\"]') !== null) {\n    return true;\n  }\n  /**\n   * Components that have an unnamed slot for the label\n   * have no other slots, so we can check the textContent\n   * of the element.\n   */\n  if (UNNAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.textContent !== '') {\n    return true;\n  }\n  return false;\n};\nconst NAMED_LABEL_SLOT_COMPONENTS = ['ION-RANGE'];\nconst UNNAMED_LABEL_SLOT_COMPONENTS = ['ION-TOGGLE', 'ION-CHECKBOX', 'ION-RADIO'];\n\nexport { createLegacyFormController as c };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-7a14ecec.js';\nimport { r as raf } from './helpers-3379ba19.js';\nimport { a as printIonError } from './index-595d62c9.js';\n\n/**\n * Used to update a scoped component that uses emulated slots. This fires when\n * content is passed into the slot or when the content inside of a slot changes.\n * This is not needed for components using native slots in the Shadow DOM.\n * @internal\n * @param el The host element to observe\n * @param slotName mutationCallback will fire when nodes on this slot change\n * @param mutationCallback The callback to fire whenever the slotted content changes\n */\nconst createSlotMutationController = (el, slotName, mutationCallback) => {\n  let hostMutationObserver;\n  let slottedContentMutationObserver;\n  if (win !== undefined && 'MutationObserver' in win) {\n    hostMutationObserver = new MutationObserver((entries) => {\n      for (const entry of entries) {\n        for (const node of entry.addedNodes) {\n          /**\n           * Check to see if the added node\n           *  is our slotted content.\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            /**\n             * If so, we want to watch the slotted\n             * content itself for changes. This lets us\n             * detect when content inside of the slot changes.\n             */\n            mutationCallback();\n            /**\n             * Adding the listener in an raf\n             * waits until Stencil moves the slotted element\n             * into the correct place in the event that\n             * slotted content is being added.\n             */\n            raf(() => watchForSlotChange(node));\n            return;\n          }\n        }\n      }\n    });\n    hostMutationObserver.observe(el, {\n      childList: true,\n    });\n  }\n  /**\n   * Listen for changes inside of the slotted content.\n   * We can listen for subtree changes here to be\n   * informed of text within the slotted content\n   * changing. Doing this on the host is possible\n   * but it is much more expensive to do because\n   * it also listens for changes to the internals\n   * of the component.\n   */\n  const watchForSlotChange = (slottedEl) => {\n    var _a;\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n    slottedContentMutationObserver = new MutationObserver((entries) => {\n      mutationCallback();\n      for (const entry of entries) {\n        for (const node of entry.removedNodes) {\n          /**\n           * If the element was removed then we\n           * need to destroy the MutationObserver\n           * so the element can be garbage collected.\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            destroySlottedContentObserver();\n          }\n        }\n      }\n    });\n    /**\n     * Listen for changes inside of the element\n     * as well as anything deep in the tree.\n     * We listen on the parentElement so that we can\n     * detect when slotted element itself is removed.\n     */\n    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, { subtree: true, childList: true });\n  };\n  const destroy = () => {\n    if (hostMutationObserver) {\n      hostMutationObserver.disconnect();\n      hostMutationObserver = undefined;\n    }\n    destroySlottedContentObserver();\n  };\n  const destroySlottedContentObserver = () => {\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n  };\n  return {\n    destroy,\n  };\n};\n\nconst getCounterText = (value, maxLength, counterFormatter) => {\n  const valueLength = value == null ? 0 : value.toString().length;\n  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\n  /**\n   * If developers did not pass a custom formatter,\n   * use the default one.\n   */\n  if (counterFormatter === undefined) {\n    return defaultCounterText;\n  }\n  /**\n   * Otherwise, try to use the custom formatter\n   * and fallback to the default formatter if\n   * there was an error.\n   */\n  try {\n    return counterFormatter(valueLength, maxLength);\n  }\n  catch (e) {\n    printIonError('Exception in provided `counterFormatter`.', e);\n    return defaultCounterText;\n  }\n};\nconst defaultCounterFormatter = (length, maxlength) => {\n  return `${length} / ${maxlength}`;\n};\n\nexport { createSlotMutationController as c, getCounterText as g };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-7a14ecec.js';\nimport { r as raf } from './helpers-3379ba19.js';\n\n/**\n * A utility to calculate the size of an outline notch\n * width relative to the content passed. This is used in\n * components such as `ion-select` with `fill=\"outline\"`\n * where we need to pass slotted HTML content. This is not\n * needed when rendering plaintext content because we can\n * render the plaintext again hidden with `opacity: 0` inside\n * of the notch. As a result we can rely on the intrinsic size\n * of the element to correctly compute the notch width. We\n * cannot do this with slotted content because we cannot project\n * it into 2 places at once.\n *\n * @internal\n * @param el: The host element\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\n * @param getLabelSlot: A function that returns a reference to the slotted content.\n */\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\n  let notchVisibilityIO;\n  const needsExplicitNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (\n    /**\n     * If the notch is not being used\n     * then we do not need to set the notch width.\n     */\n    notchSpacerEl === undefined ||\n      /**\n       * If either the label property is being\n       * used or the label slot is not defined,\n       * then we do not need to estimate the notch width.\n       */\n      el.label !== undefined ||\n      getLabelSlot() === null) {\n      return false;\n    }\n    return true;\n  };\n  const calculateNotchWidth = () => {\n    if (needsExplicitNotchWidth()) {\n      /**\n       * Run this the frame after\n       * the browser has re-painted the host element.\n       * Otherwise, the label element may have a width\n       * of 0 and the IntersectionObserver will be used.\n       */\n      raf(() => {\n        setNotchWidth();\n      });\n    }\n  };\n  /**\n   * When using a label prop we can render\n   * the label value inside of the notch and\n   * let the browser calculate the size of the notch.\n   * However, we cannot render the label slot in multiple\n   * places so we need to manually calculate the notch dimension\n   * based on the size of the slotted content.\n   *\n   * This function should only be used to set the notch width\n   * on slotted label content. The notch width for label prop\n   * content is automatically calculated based on the\n   * intrinsic size of the label text.\n   */\n  const setNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (notchSpacerEl === undefined) {\n      return;\n    }\n    if (!needsExplicitNotchWidth()) {\n      notchSpacerEl.style.removeProperty('width');\n      return;\n    }\n    const width = getLabelSlot().scrollWidth;\n    if (\n    /**\n     * If the computed width of the label is 0\n     * and notchSpacerEl's offsetParent is null\n     * then that means the element is hidden.\n     * As a result, we need to wait for the element\n     * to become visible before setting the notch width.\n     *\n     * We do not check el.offsetParent because\n     * that can be null if the host element has\n     * position: fixed applied to it.\n     * notchSpacerEl does not have position: fixed.\n     */\n    width === 0 &&\n      notchSpacerEl.offsetParent === null &&\n      win !== undefined &&\n      'IntersectionObserver' in win) {\n      /**\n       * If there is an IO already attached\n       * then that will update the notch\n       * once the element becomes visible.\n       * As a result, there is no need to create\n       * another one.\n       */\n      if (notchVisibilityIO !== undefined) {\n        return;\n      }\n      const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\n        /**\n         * If the element is visible then we\n         * can try setting the notch width again.\n         */\n        if (ev[0].intersectionRatio === 1) {\n          setNotchWidth();\n          io.disconnect();\n          notchVisibilityIO = undefined;\n        }\n      }, \n      /**\n       * Set the root to be the host element\n       * This causes the IO callback\n       * to be fired in WebKit as soon as the element\n       * is visible. If we used the default root value\n       * then WebKit would only fire the IO callback\n       * after any animations (such as a modal transition)\n       * finished, and there would potentially be a flicker.\n       */\n      { threshold: 0.01, root: el }));\n      io.observe(notchSpacerEl);\n      return;\n    }\n    /**\n     * If the element is visible then we can set the notch width.\n     * The notch is only visible when the label is scaled,\n     * which is why we multiply the width by 0.75 as this is\n     * the same amount the label element is scaled by in the host CSS.\n     * (See $form-control-label-stacked-scale in ionic.globals.scss).\n     */\n    notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\n  };\n  const destroy = () => {\n    if (notchVisibilityIO) {\n      notchVisibilityIO.disconnect();\n      notchVisibilityIO = undefined;\n    }\n  };\n  return {\n    calculateNotchWidth,\n    destroy,\n  };\n};\n\nexport { createNotchController as c };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst hostContext = (selector, el) => {\n  return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nconst createColorClasses = (color, cssClassMap) => {\n  return typeof color === 'string' && color.length > 0\n    ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nconst getClassList = (classes) => {\n  if (classes !== undefined) {\n    const array = Array.isArray(classes) ? classes : classes.split(' ');\n    return array\n      .filter((c) => c != null)\n      .map((c) => c.trim())\n      .filter((c) => c !== '');\n  }\n  return [];\n};\nconst getClassMap = (classes) => {\n  const map = {};\n  getClassList(classes).forEach((c) => (map[c] = true));\n  return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nconst openURL = async (url, ev, direction, animation) => {\n  if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n    const router = document.querySelector('ion-router');\n    if (router) {\n      if (ev != null) {\n        ev.preventDefault();\n      }\n      return router.push(url, direction, animation);\n    }\n  }\n  return false;\n};\n\nexport { createColorClasses as c, getClassMap as g, hostContext as h, openURL as o };\n"],"names":["h","findItemLabel","createLegacyFormController","el","controlEl","legacyControl","hasLegacyControl","undefined","hasLabelProp","label","hasLabelSlot","hasAriaLabelAttribute","hasAttribute","shadowRoot","legacyItemLabel","legacy","root","NAMED_LABEL_SLOT_COMPONENTS","includes","tagName","querySelector","UNNAMED_LABEL_SLOT_COMPONENTS","textContent","c","w","win","r","raf","a","printIonError","createSlotMutationController","slotName","mutationCallback","hostMutationObserver","slottedContentMutationObserver","MutationObserver","entries","entry","node","addedNodes","nodeType","Node","ELEMENT_NODE","slot","watchForSlotChange","observe","childList","slottedEl","_a","disconnect","removedNodes","destroySlottedContentObserver","parentElement","subtree","destroy","getCounterText","value","maxLength","counterFormatter","valueLength","toString","length","defaultCounterText","defaultCounterFormatter","e","maxlength","g","createNotchController","getNotchSpacerEl","getLabelSlot","notchVisibilityIO","needsExplicitNotchWidth","notchSpacerEl","calculateNotchWidth","setNotchWidth","style","removeProperty","width","scrollWidth","offsetParent","io","IntersectionObserver","ev","intersectionRatio","threshold","setProperty","hostContext","selector","closest","createColorClasses","color","cssClassMap","Object","assign","getClassList","classes","array","Array","isArray","split","filter","map","trim","getClassMap","forEach","SCHEME","openURL","url","direction","animation","test","router","document","preventDefault","push","o"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1,2,3]}